Вариант 24

Исходная регулярка  
 `^(((?:\2a\2b)|a)*)bab\1$`   

Часть `(?:\2a\2b)|a)`  
Задает язык L = { $w_n$ }  

$w1 = a$  
$w2 = aaab$  
$w3 = aaaba aaabb$  
$w4 = aaabaaaabba aaabaaaabbb$  
$w_{n+1} = w_n a w_n b$

Тогда часть `((?:\2a\2b)|a)*)`  
Задает язык $W = v_1v_2v_3 ... v_n$  

Где $v_k ∈ L$  
$v_1 = w_1$  
И, если $v_k = w_n$  то $v_{k+1} = w_1$ или $v_{k+1} = w_{n+1}$  

Тогда весь язык - это  
$x_1 bab x_1$ где $x_1 ∈ W$  

Возьмем пересечение языка с регуляркой `a*(aaaab)*abaa*(aaaab)*`

Оно состоит из всех слов вида $a^{n} (aaaab)^k aba a^n (aaaab)^k$  
Возьмем для длины накачки p слово $a^p (aaaab)^p aba a^p (aaaab)^p$

Разобьём его на 5 блоков длины p, 5p, 3, p и 5p соответственно.  
Накачка внутри любого блока, не ломающая принадлежность регулярке, ломает либо равенство длин блоков 1 и 4 либо 2 и 5.  
Накачка между двумя соседними блоками или блоками 2 и 4, не ломающая принадлежность регулярке, будет также ломать хотя бы одно равенств.  

Следовательно, по лемме о накачке, такой язык не КС. А значит и исходный язык не КС.  

Построить нормальные графики времени работы тяжело, в силу особенностей функции TimeElapsed, описанных в комментариях к коду.  

Без графиков можно сказать, что на большом пуле полностью случайных слов, не принадлежащих языку, при росте длины слов в пуле, отношение между временем работы парсеров будет сохраняться одинаковым, а для пула слов, принадлежащих языку, при росте длины слов в пуле, время работы наивного парсера будет расти относительно времени оптимизированного, как $O(O(2^n)/O(n)) = O(2^n)$
